/-
Refinement proofs to show equivalence between the functional and propositional specifications.

Copyright (c) 2025 Igor Konnov
Released under MIT license as described in the file LICENSE.
Authors: Igor Konnov, 2025
-/

import Twophase.Propositional

-- The abstract type of resource managers.
variable { RM : Type } [DecidableEq RM] [Hashable RM]

-- Connecting the denotational and functional specifications.
-- Effort: 2.5h

theorem tm_rcv_prepared_correct (s: ProtocolState RM) (s': ProtocolState RM)
    (rm: RM): tm_rcv_prepared s s' rm ↔ tmRcvPrepared RM s rm = some s' := by
  apply Iff.intro
  case mp =>
    intro hrel
    simp [tm_rcv_prepared] at hrel
    rcases hrel with ⟨ h_tmState, h_msgs, h_tmPrepared', h_tmState',
      h_rmState', h_msgs', h_all' ⟩
    simp [tmRcvPrepared, h_tmState, h_msgs]
    rw [h_tmState] at h_tmState'
    apply ProtocolState.ext
    repeat simp [*]

  case mpr =>
    intro heq
    simp [tmRcvPrepared] at heq
    rcases heq with ⟨ ⟨ h_tmState, h_msgs ⟩, h_seq ⟩
    unfold tm_rcv_prepared
    simp [h_tmState, h_msgs]
    rw [h_tmState] at h_seq
    cases h_seq; simp

theorem tm_commit_correct (s: ProtocolState RM) (s': ProtocolState RM):
    tm_commit s s' ↔ tmCommit RM s = some s' := by
  apply Iff.intro
  case mp =>
    intro hrel
    simp [tm_commit] at hrel
    rcases hrel with ⟨ h_tmState, h_tmPrepared, h_tmState', h_msgs',
      h_tmPrepared', h_rmState', h_all' ⟩
    simp [tmCommit, h_tmState, h_tmPrepared]
    apply ProtocolState.ext
    repeat simp [*]

  case mpr =>
    intro heq
    simp [tmCommit] at heq
    rcases heq with ⟨ ⟨ h_tmState, h_tmPrepared ⟩, h_seq ⟩
    unfold tm_commit
    simp [h_tmState, h_tmPrepared]
    cases h_seq
    repeat simp [*]

theorem tm_abort_correct (s: ProtocolState RM) (s': ProtocolState RM):
    tm_abort s s' ↔ tmAbort RM s = some s' := by
  apply Iff.intro
  case mp =>
    intro hrel
    simp [tm_abort] at hrel
    rcases hrel with ⟨ h_tmState, h_tmState', h_msgs', h_tmPrepared',
      h_rmState', h_all' ⟩
    simp [tmAbort, h_tmState]
    apply ProtocolState.ext
    repeat simp [*]

  case mpr =>
    intro heq
    simp [tmAbort] at heq
    rcases heq with ⟨ h_tmState, h_seq ⟩
    unfold tm_abort
    simp [h_tmState]
    cases h_seq
    repeat simp [*]

theorem rm_prepare_correct (s: ProtocolState RM) (s': ProtocolState RM) (rm: RM):
    rm_prepare s s' rm ↔ rmPrepare RM s rm = some s' := by
  -- completely generated by Copilot from the above proofs
  apply Iff.intro
  case mp =>
    intro hrel
    simp [rm_prepare] at hrel
    rcases hrel with
      ⟨ h_rmState, h_rmState', h_msgs', h_tmState', h_tmPrepared', h_all' ⟩
    simp [rmPrepare, h_rmState]
    apply ProtocolState.ext
    repeat simp [*]

  case mpr =>
    intro heq
    simp [rmPrepare] at heq
    rcases heq with ⟨ h_rmState, h_seq ⟩
    unfold rm_prepare
    simp [h_rmState]
    cases h_seq
    repeat simp [*]

theorem rm_choose_to_abort_correct (s: ProtocolState RM) (s': ProtocolState RM) (rm: RM):
    rm_choose_to_abort s s' rm ↔ rmChooseToAbort RM s rm = some s' := by
  -- completely generated by Copilot from the above proofs
  apply Iff.intro
  case mp =>
    intro hrel
    simp [rm_choose_to_abort] at hrel
    rcases hrel with
      ⟨ h_rmState, h_rmState', h_msgs', h_tmState', h_tmPrepared', h_all' ⟩
    simp [rmChooseToAbort, h_rmState]
    apply ProtocolState.ext
    repeat simp [*]

  case mpr =>
    intro heq
    simp [rmChooseToAbort] at heq
    rcases heq with ⟨ h_rmState, h_seq ⟩
    unfold rm_choose_to_abort
    simp [h_rmState]
    cases h_seq
    repeat simp [*]

theorem rm_rcv_commit_msg_correct (s: ProtocolState RM) (s': ProtocolState RM) (rm: RM):
    rm_rcv_commit_msg s s' rm ↔ rmRcvCommitMsg RM s rm = some s' := by
  -- completely generated by Copilot from the above proofs
  apply Iff.intro
  case mp =>
    intro hrel
    simp [rm_rcv_commit_msg] at hrel
    rcases hrel with
      ⟨ h_msgs, h_rmState', h_msgs', h_tmState', h_tmPrepared', h_all' ⟩
    simp [rmRcvCommitMsg, h_msgs]
    apply ProtocolState.ext
    repeat simp [*]

  case mpr =>
    intro heq
    simp [rmRcvCommitMsg] at heq
    rcases heq with ⟨ h_msgs, h_seq ⟩
    unfold rm_rcv_commit_msg
    simp [h_msgs]
    cases h_seq
    repeat simp [*]

theorem rm_rcv_abort_msg_correct (s: ProtocolState RM) (s': ProtocolState RM) (rm: RM):
    rm_rcv_abort_msg s s' rm ↔ rmRcvAbortMsg RM s rm = some s' := by
  -- completely generated by Copilot from the above proofs
  apply Iff.intro
  case mp =>
    intro hrel
    simp [rm_rcv_abort_msg] at hrel
    rcases hrel with
      ⟨ h_msgs, h_rmState', h_msgs', h_tmState', h_tmPrepared', h_all' ⟩
    simp [rmRcvAbortMsg, h_msgs]
    apply ProtocolState.ext
    repeat simp [*]

  case mpr =>
    intro heq
    simp [rmRcvAbortMsg] at heq
    rcases heq with ⟨ h_msgs, h_seq ⟩
    unfold rm_rcv_abort_msg
    simp [h_msgs]
    cases h_seq
    repeat simp [*]

/-- Refinement between the initial conditions. -/
-- Total effort: 4.5h, due to the wrong initial choice of tp_init.
-- After choosing the right structure, the proof took about 30 min.
theorem tp_init_correct (all: List RM) (s: ProtocolState RM):
    tp_init all s ↔ init all = s := by
  apply Iff.intro
  case mp =>
    intro hrel
    simp [tp_init] at hrel
    rcases hrel with ⟨ h_all, h_rmState, h_tmState, h_tmPrepared, h_msgs ⟩
    unfold init
    apply ProtocolState.ext
    repeat simp [*]

  case mpr =>
    intro heq
    simp [init] at heq
    unfold tp_init
    cases heq; repeat simp

/-- Refinement between the transitions. -/
-- Total effort: 1h
theorem tp_next_correct (s: ProtocolState RM) (s': ProtocolState RM):
    tp_next s s' ↔ ∃ a: Action, next s a = some s' := by
  apply Iff.intro
  case mp =>
    intro hrel
    simp [tp_next] at hrel
    -- do case analysis on the disjunction structure and apply the refinement theorems
    cases hrel
    case inl h_tm_commit =>
      exists Action.TMCommit
      unfold next
      simp [tm_commit_correct] at h_tm_commit
      exact h_tm_commit

    case inr h_rest =>
      cases h_rest
      case inl h_tm_abort =>
        exists Action.TMAbort
        unfold next
        simp [tm_abort_correct] at h_tm_abort
        exact h_tm_abort

      case inr h_rest =>
        -- ∃ rm, ...
        rcases h_rest with ⟨rm, h_act⟩
        cases h_act
        case inl h_tm_rcv_prepared =>
          exists (Action.TMRcvPrepared rm)
          unfold next
          simp [tm_rcv_prepared_correct] at h_tm_rcv_prepared
          exact h_tm_rcv_prepared

        case inr h_rest =>
          cases h_rest
          case inl h_rm_prepare =>
            exists (Action.RMPrepare rm)
            unfold next
            simp [rm_prepare_correct] at h_rm_prepare
            exact h_rm_prepare

          case inr h_rest =>
            cases h_rest
            case inl h_rm_choose_to_abort =>
              exists (Action.RMChooseToAbort rm)
              unfold next
              simp [rm_choose_to_abort_correct] at h_rm_choose_to_abort
              exact h_rm_choose_to_abort

            case inr h_rest =>
              cases h_rest
              case inl h_rm_rcv_commit_msg =>
                exists (Action.RMRcvCommitMsg rm)
                unfold next
                simp [rm_rcv_commit_msg_correct] at h_rm_rcv_commit_msg
                exact h_rm_rcv_commit_msg

              case inr h_rm_rcv_abort_msg =>
                exists (Action.RMRcvAbortMsg rm)
                unfold next
                simp [rm_rcv_abort_msg_correct] at h_rm_rcv_abort_msg
                exact h_rm_rcv_abort_msg

  case mpr =>
    intro ⟨a, heq⟩
    match a with
    | Action.TMCommit =>
      simp [next] at heq
      unfold tp_next
      rw [← tm_commit_correct] at heq
      simp [heq]

    | Action.TMAbort =>
      simp [next] at heq
      unfold tp_next
      rw [← tm_abort_correct] at heq
      simp [heq]

    | Action.TMRcvPrepared rm =>
      simp [next] at heq
      unfold tp_next
      rw [← tm_rcv_prepared_correct] at heq
      have h: ∃ rm, tm_rcv_prepared s s' rm
        ∨ rm_prepare s s' rm ∨ rm_choose_to_abort s s' rm
        ∨ rm_rcv_commit_msg s s' rm ∨ rm_rcv_abort_msg s s' rm := by
        exists rm
        simp [heq]
      simp [h]

    | Action.RMPrepare rm =>
      simp [next] at heq
      unfold tp_next
      rw [← rm_prepare_correct] at heq
      have h: ∃ rm, tm_rcv_prepared s s' rm
        ∨ rm_prepare s s' rm ∨ rm_choose_to_abort s s' rm
        ∨ rm_rcv_commit_msg s s' rm ∨ rm_rcv_abort_msg s s' rm := by
        exists rm
        simp [heq]
      simp [h]

    | Action.RMChooseToAbort rm =>
      -- generated by Copilot
      simp [next] at heq
      unfold tp_next
      rw [← rm_choose_to_abort_correct] at heq
      have h: ∃ rm, tm_rcv_prepared s s' rm
        ∨ rm_prepare s s' rm ∨ rm_choose_to_abort s s' rm
        ∨ rm_rcv_commit_msg s s' rm ∨ rm_rcv_abort_msg s s' rm := by
        exists rm
        simp [heq]
      simp [h]

    | Action.RMRcvCommitMsg rm =>
      -- generated by Copilot
      simp [next] at heq
      unfold tp_next
      rw [← rm_rcv_commit_msg_correct] at heq
      have h: ∃ rm, tm_rcv_prepared s s' rm
        ∨ rm_prepare s s' rm ∨ rm_choose_to_abort s s' rm
        ∨ rm_rcv_commit_msg s s' rm ∨ rm_rcv_abort_msg s s' rm := by
        exists rm
        simp [heq]
      simp [h]

    | Action.RMRcvAbortMsg rm =>
      -- generated by Copilot
      simp [next] at heq
      unfold tp_next
      rw [← rm_rcv_abort_msg_correct] at heq
      have h: ∃ rm, tm_rcv_prepared s s' rm
        ∨ rm_prepare s s' rm ∨ rm_choose_to_abort s s' rm
        ∨ rm_rcv_commit_msg s s' rm ∨ rm_rcv_abort_msg s s' rm := by
        exists rm
        simp [heq]
      simp [h]
